package org.firstinspires.ftc.teamcode.HardwareClasses;import android.os.Build;import androidx.annotation.RequiresApi;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.DcMotorSimple;import com.qualcomm.robotcore.util.Range;import org.firstinspires.ftc.utilities.MathUtils;import org.firstinspires.ftc.utilities.PID;import org.firstinspires.ftc.utilities.RingBuffer;import org.firstinspires.ftc.utilities.RingBufferOwen;import static java.lang.Math.abs;import static java.lang.Math.max;import static java.lang.Math.PI;import static java.lang.Math.min;import static java.lang.Math.floorMod;import static org.firstinspires.ftc.utilities.MathUtils.pow;public class MecanumDrive {    public DcMotor frontLeft, frontRight, backLeft, backRight;        private final PID telePID = new PID(.02, 0, .004, 8);    private final PID autoPID = new PID(.02, 0, .003, 8);    private final PID visionPID = new PID(0.06, 0, .007, 10);        private DriveState currentDriveState = DriveState.FULL_CONTROL;        private double drive = 0, strafe = 0, turn = 0, power = 1;    public double targetAngle;    public double releaseAngle = 0;    public double adjRateOfChange = 0;        private double startAngle = 0;    public double currentInches = 0;    public boolean isStrafeComplete = true;    public boolean isTurnComplete = true;        private int powerShotState = 3;    private double adjustmentAngle = 0;    private double towerAimAngle = 0;    private double PSAngle = 0;            public MecanumDrive(DcMotor frontLeft, DcMotor frontRight, DcMotor backLeft, DcMotor backRight) {        frontRight.setDirection(DcMotorSimple.Direction.FORWARD);        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);        backRight.setDirection(DcMotorSimple.Direction.FORWARD);        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);        frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        frontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        this.frontLeft = frontLeft;        this.frontRight = frontRight;        this.backLeft = backLeft;        this.backRight = backRight;    }    public void resetGyro(double offsetAngle){        Sensors.gyro.setDatum(Sensors.gyro.getIMUAngle() + offsetAngle);        Sensors.gyro.update();        targetAngle = Sensors.gyro.getRawAngle();        releaseAngle = Sensors.gyro.getRawAngle();        adjRateOfChange = 0;    }    @RequiresApi(api = Build.VERSION_CODES.N)    public double closestTarget(double targetAngle){        double simpleTargetDelta = floorMod(Math.round(((360 - targetAngle) + Sensors.gyro.getRawAngle()) * 1e6), Math.round(360.000 * 1e6)) / 1e6;        double alternateTargetDelta = -1 * (360 - simpleTargetDelta);        return StrictMath.abs(simpleTargetDelta) <= StrictMath.abs(alternateTargetDelta) ? Sensors.gyro.getRawAngle() - simpleTargetDelta : Sensors.gyro.getRawAngle() - alternateTargetDelta;    }            //SET POWER METHODS            public void setPower(double drive, double strafe, double turn, double power){        this.drive = Range.clip(drive, -1, 1);        this.strafe = Range.clip(strafe, -1, 1);        this.turn = Range.clip(turn, -1, 1);        this.power = Range.clip(power, 0.05 , 1);                double flPower = (this.drive - this.strafe - this.turn) * this.power;        double frPower = (this.drive + this.strafe + this.turn) * this.power;        double blPower = (this.drive + this.strafe - this.turn) * this.power;        double brPower = (this.drive - this.strafe + this.turn) * this.power;                double maxPower = abs(max(max(abs(flPower), abs(frPower)), max(abs(blPower), abs(brPower))));        if(maxPower > 1) { frPower /= maxPower; flPower /= maxPower; blPower /= maxPower; brPower /= maxPower; }        else if(maxPower < .05 && maxPower > -.05) { flPower = 0; frPower = 0; blPower = 0; brPower = 0; }                setMotorPower(flPower, frPower, blPower, brPower);    }        @RequiresApi(api = Build.VERSION_CODES.N)    public void setPowerTele(double drive, double strafe, double turn, double power){        double inputTurn;                if(turn!= 0) {            inputTurn = turn;            releaseAngle = Sensors.gyro.getRawAngle();            adjRateOfChange = pow(Sensors.gyro.rateOfChange(), 2);        }else if(adjRateOfChange > 1000){            releaseAngle = Sensors.gyro.getRawAngle();            adjRateOfChange = pow(Sensors.gyro.rateOfChange(), 2);            inputTurn = 0;        }else{            targetAngle = releaseAngle + .5 * .0035 * adjRateOfChange;            inputTurn = telePID.update(closestTarget(targetAngle) - Sensors.gyro.getRawAngle());        }        setPower(drive, strafe, inputTurn, power);    }            @RequiresApi(api = Build.VERSION_CODES.N)    public void setPowerAuto(double drive, double strafe, double targetAngle, double power){        this.targetAngle = targetAngle;        releaseAngle = Sensors.gyro.getRawAngle();        turn = autoPID.update(this.targetAngle - Sensors.gyro.getRawAngle());        setPower(drive, strafe, turn, power);    }        @RequiresApi(api = Build.VERSION_CODES.N)    public void setPowerAuto(double drive, double strafe, double targetAngle){        setPowerAuto(drive, strafe, targetAngle,1.0);    }        @RequiresApi(api = Build.VERSION_CODES.N)    public void setPowerVision(double drive, double strafe, double targetAngle, double power){        this.targetAngle = targetAngle;        releaseAngle = Sensors.gyro.getRawAngle();        turn = visionPID.update(pow(targetAngle - Sensors.gyro.getRawAngle(), .7));        runWithEncoders();        setPower(drive, strafe, turn, power);    }        @RequiresApi(api = Build.VERSION_CODES.N)    public void setPowerVision(double drive, double strafe, double targetAngle){        setPowerAuto(drive, strafe, targetAngle,1.0);    }            //AUTO METHODS            @RequiresApi(api = Build.VERSION_CODES.N)    public void strafe(double distance, double heading, double strafeAngle, double targetPower, double startPower, double endPower){            distance = abs((distance) / 0.0207);        startPower = abs(startPower);        targetPower = abs(targetPower);        endPower = abs(endPower);            double deceleratePower;        double accelRate = 0.0013;            if (isStrafeComplete){            resetWithoutEncoders();        }                double currentAngle = Sensors.gyro.getRawAngle();                double drive = MathUtils.degSin(strafeAngle - currentAngle);        double strafe = MathUtils.degSin(strafeAngle - currentAngle);                double currentDistance = adjustedTicks();                if(distance != 0){            double remainingDistance = distance - currentDistance;            deceleratePower = Math.sqrt(accelRate * (remainingDistance + 1.0/accelRate * Math.pow(endPower, 2))) + .05;            isStrafeComplete = currentDistance >= distance;        }else{            deceleratePower = 1;            isStrafeComplete = false;        }                double acceleratePower = Math.sqrt(accelRate * (currentDistance + 1.0/accelRate * Math.pow(startPower, 2))) + .05;        double currentPower = min(min(acceleratePower, deceleratePower), targetPower);                currentInches = (0.0207 * currentDistance);                setPowerAuto(drive, strafe, closestTarget(heading), currentPower);            }    public double adjustedTicks() {        double measuredTicks = ((abs(frontRight.getCurrentPosition()) + abs(frontLeft.getCurrentPosition()) + abs(backRight.getCurrentPosition()) + abs(backLeft.getCurrentPosition())) / 4.0);        double angleAdjustment = (abs(abs(drive) - abs(strafe)) - 1) * -1;        return Math.sqrt(Math.pow(measuredTicks, 2) + Math.pow(measuredTicks * angleAdjustment, 2));    }                @RequiresApi(api = Build.VERSION_CODES.N)    public void turn(double targetAngle, double targetPower, double startPower){        targetPower = abs(targetPower);        double accelRate = 0.03;        double currentAngle = Sensors.gyro.getRawAngle();                if(isTurnComplete){            startAngle = Sensors.gyro.getRawAngle();            resetWithEncoders();        }                double acceleratePower = Math.sqrt(accelRate * (abs(currentAngle - startAngle)+ 1/accelRate * Math.pow(startPower, 2))) + .05;        double currentPower = min(acceleratePower, targetPower);                if(startAngle > closestTarget(targetAngle)){            isTurnComplete = currentAngle < closestTarget(targetAngle) + 2.5;        }else{            isTurnComplete = currentAngle > closestTarget(targetAngle) - 2.5;        }                isStrafeComplete = isTurnComplete;                setPowerAuto(0,0, closestTarget(targetAngle), currentPower);    }            //TELEOP METHODS            @RequiresApi(api = Build.VERSION_CODES.N)    public void driveState(double drive, double strafe, double turn, double power){        power = (((power + 1) / -2) + 1.5);        switch ( currentDriveState){                    case FULL_CONTROL:                setPowerTele(drive, strafe, turn, power);                break;                    case NORTH:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(0), power);                break;                    case EAST:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(270), power);                break;                    case SOUTH:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(180), power);                break;                    case WEST:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(90), power);                break;                case ADJUSTMENT:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                setPowerAuto(drive, strafe, getAdjustmentAngle(), power);                break;            case TOWER_AIM:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                if (Sensors.frontCamera.isTowerFound() && !Sensors.gyro.angleRange(25, 155)) setPowerVision(drive, strafe, closestTarget(getTowerAimAngle()), power);                else setPowerAuto(drive, strafe, closestTarget(90));                break;                            case POWER_SHOT_AIM:                if(turn != 0) { newState(DriveState.FULL_CONTROL); break; }                if (Sensors.frontCamera.isTowerFound() && !Sensors.gyro.angleRange(25, 155)) setPowerVision(drive, strafe, closestTarget(getPSAngle()), power);                else setPowerAuto(drive, strafe, closestTarget(90));                break;        }    }        @RequiresApi(api = Build.VERSION_CODES.N)    //if the boolean is true, it sets the targetAngle for the PID system to the closest coterminal angle to the input's respective angle (North 0, East 270, South 180, West 90) with priority being in that order    public void cardinalState(boolean north, boolean east, boolean south, boolean west){        if(north) { newState(DriveState.NORTH); }        if(east) { newState(DriveState.EAST); }        if(west) { newState(DriveState.WEST); }        if(south) { newState(DriveState.SOUTH); }    }    public void autoAimState(boolean autoAim, boolean autoAimToggle, boolean adjRight, boolean adjLeft, double adjDeltaAngle){        if(autoAimToggle && Shooter.currentShooterState == Shooter.ShooterState.TOP_GOAL){            if(autoAim || Shooter.shooterJustOn) newState(DriveState.TOWER_AIM);            setTowerAimAngle(Sensors.gyro.getRawAngle() + Sensors.frontCamera.towerAimError());        }                        if(autoAimToggle && Shooter.currentShooterState == Shooter.ShooterState.POWER_SHOT) {            if (autoAim || Shooter.shooterJustOn) newState(DriveState.POWER_SHOT_AIM);;                            if (Shooter.shooterJustOn) powerShotState = 0;            if (Shooter.feederJustOn || adjRight) powerShotState++;            if (adjLeft) powerShotState--;            powerShotState %= 3;                switch (powerShotState) {                case 0:                    setPSAngle(Sensors.gyro.getRawAngle() + Sensors.frontCamera.leftPSAimError());                    break;                case 1:                    setPSAngle(Sensors.gyro.getRawAngle() + Sensors.frontCamera.centerPSAimError());                    break;                case 2:                    setPSAngle(Sensors.gyro.getRawAngle() + Sensors.frontCamera.rightPSAimError());                    break;                }        }else{            if(adjRight) { newState(DriveState.ADJUSTMENT); setAdjustmentAngle(Sensors.gyro.getRawAngle() - adjDeltaAngle); }            if(adjLeft) { newState(DriveState.ADJUSTMENT); setAdjustmentAngle(Sensors.gyro.getRawAngle() + adjDeltaAngle); }        }    }        public void setAdjustmentAngle(double adjustmentAngle){ this.adjustmentAngle = adjustmentAngle; }        public double getAdjustmentAngle(){ return adjustmentAngle; }        public void setTowerAimAngle(double towerAimAngle){ this.towerAimAngle = towerAimAngle - 3; }    public double getTowerAimAngle(){ return towerAimAngle; }        public void setPSAngle(double PSAngle){ this.PSAngle = PSAngle; }        public double getPSAngle(){ return PSAngle; }            //MOTOR METHODS            public void setMotorPower(double flPower, double frPower, double blPower, double brPower){        frontLeft.setPower(flPower);        frontRight.setPower(frPower);        backLeft.setPower(blPower);        backRight.setPower(brPower);    }        public void runWithEncoders(){        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);    }        public void runWithoutEncoders(){        frontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);    }        public void stopAndResetEncodes(){        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);    }        public void resetWithoutEncoders(){        stopAndResetEncodes();        runWithoutEncoders();    }        public void resetWithEncoders(){        stopAndResetEncodes();        runWithEncoders();    }        //STATE MACHINE STUFF            private void newState(DriveState newState) {        currentDriveState = newState;        runWithoutEncoders();    }        private enum DriveState {        FULL_CONTROL,        NORTH,        EAST,        SOUTH,        WEST,        ADJUSTMENT,        TOWER_AIM,        POWER_SHOT_AIM    }    }