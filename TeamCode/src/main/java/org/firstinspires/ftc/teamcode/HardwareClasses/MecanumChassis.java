package org.firstinspires.ftc.teamcode.HardwareClasses;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.DcMotorSimple;import org.firstinspires.ftc.utilities.PID;import org.firstinspires.ftc.utilities.RingBuffer;import org.firstinspires.ftc.utilities.RingBufferOwen;public class MecanumChassis {    public DcMotor frontLeft, frontRight, backLeft, backRight;    private PID telePID = new PID(.015, 0.0000, .0004, 20);    private PID autoPID = new PID(.02, 0.0000, .0004, 20);    private final RingBufferOwen timeRing = new RingBufferOwen(20);    private final RingBuffer<Double> positionRingFL = new RingBuffer<Double>(20, 0.0);    private final RingBuffer<Double> positionRingFR = new RingBuffer<Double>(20, 0.0);    private final RingBuffer<Double> positionRingBL = new RingBuffer<Double>(20, 0.0);    private final RingBuffer<Double> positionRingBR = new RingBuffer<Double>(20, 0.0);        private DriveState currentDriveState = DriveState.STATE_FULL_CONTROL;        private Gyro gyro;    private double drive, strafe, turn, power, targetAngle, bigTurn;    private double closestTarget = 0;    private double previousTarget = 0;    private double turnTime = 0;    private double turnYInt = 0;    private double unique = 238208;    public double currentTicks = 0;    public boolean isStrafeFinished = false;    private double adjustmentAngle = 0;    private final static double ACCEL_RATE = 0.001;    private static final double TELE_ACCEL = .002;    public MecanumChassis(DcMotor frontLeft, DcMotor frontRight, DcMotor backLeft, DcMotor backRight, Gyro gyro) {        frontRight.setDirection(DcMotorSimple.Direction.FORWARD);        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);        backRight.setDirection(DcMotorSimple.Direction.FORWARD);        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);                this.frontLeft = frontLeft;        this.frontRight = frontRight;        this.backLeft = backLeft;        this.backRight = backRight;        this.gyro = gyro;    }    public void resetGyro(){        gyro.setDatum(gyro.getRawAngle());        targetAngle = 0;    }        public double closestTarget(double targetAngle){        if(previousTarget != targetAngle) {            double currentAngle = gyro.getRawAngle();            double modCurrentAngle = currentAngle % 360;            double modTargetAngle = targetAngle % 360;            double adjTargetAngle;                if (modTargetAngle - modCurrentAngle > 180) {                adjTargetAngle = modTargetAngle - 360;            } else if (modTargetAngle - modCurrentAngle < -180) {                adjTargetAngle = modTargetAngle + 360;            } else {                adjTargetAngle = modTargetAngle;            }            closestTarget = currentAngle - modCurrentAngle + adjTargetAngle;        }        previousTarget = targetAngle;        return closestTarget;    }        public void setPower(double drive, double strafe, double turn, double power){        this.drive = drive;        this.strafe = strafe;        this.turn = turn;        this.power = power;                double flPower = (this.drive - this.strafe - this.turn) * this.power;        double frPower = (this.drive + this.strafe + this.turn) * this.power;        double blPower = (this.drive + this.strafe - this.turn) * this.power;        double brPower = (this.drive - this.strafe + this.turn) * this.power;        double maxPower = Math.abs(Math.max(Math.max(Math.abs(flPower), Math.abs(frPower)), Math.max(Math.abs(blPower), Math.abs(brPower))));            if (maxPower > 1) {            flPower = flPower / maxPower;            frPower = frPower / maxPower;            blPower = blPower / maxPower;            brPower = brPower / maxPower;        }                if(maxPower < .05 && maxPower > -.05) {            flPower = 0;            frPower = 0;            blPower = 0;            brPower = 0;        }            this.frontLeft.setPower(flPower);        this.frontRight.setPower(frPower);        this.backLeft.setPower(blPower);        this.backRight.setPower(brPower);            }    public void setPowerTele(double drive, double strafe, double turn, double power){        double currentTime = System.currentTimeMillis();        double deltaTime = currentTime - turnTime;        double inputTurn;                if (turn != 0) {            inputTurn = turn;            bigTurn = turn;            turnTime = currentTime;            turnYInt = bigTurn;            targetAngle = gyro.getRawAngle();        }else {            if(bigTurn > .1) {                bigTurn = Math.max(0, -TELE_ACCEL * deltaTime + turnYInt);                targetAngle = gyro.getRawAngle();            }else if(bigTurn < -.1) {                bigTurn = Math.min(0, TELE_ACCEL * deltaTime + turnYInt);                targetAngle = gyro.getRawAngle();            }else{                bigTurn = 0;            }           inputTurn = telePID.update((targetAngle - gyro.getRawAngle()) / ((getRPM() / 600) + .5));                    }        setPower(drive, strafe, inputTurn, power);    }    public void setPowerTele(double drive, double strafe, double turn){        setPowerTele(drive, strafe, turn,1.0);    }        public void setPowerAuto(double drive, double strafe, double targetAngle, double power){        this.targetAngle = targetAngle;        turn = autoPID.update(this.targetAngle - gyro.getRawAngle());        setPower(drive, strafe, turn, power);    }        public void strafe(double distance, double heading, double strafeAngle, double targetPower, double startPower, double endPower, int unique){                distance = Math.abs(distance);        if(startPower == 0){            startPower = .05;        }        startPower = Math.abs(startPower);        targetPower = Math.abs(targetPower);        endPower = Math.abs(endPower);            if (this.unique != unique){            resetMotors();            this.unique = unique;        }            double currentAngle = gyro.getRawAngle();        double currentDistance = frontLeft.getCurrentPosition();        double remainingDistance = distance - currentDistance;                double accelRate = 0.003;        double acceleratePower = Math.sqrt(accelRate * (currentDistance + 1/accelRate * Math.pow(startPower, 2)));        double deceleratePower = Math.sqrt(accelRate * (remainingDistance + 1/accelRate * Math.pow(endPower, 2)));        double currentPower = Math.min(Math.min(acceleratePower, deceleratePower), targetPower);            double drive = Math.cos(strafeAngle - currentAngle);        double strafe = Math.sin(strafeAngle - currentAngle);        double turn = autoPID.update(heading - currentAngle);            isStrafeFinished = currentDistance >= distance;        currentTicks = currentDistance;                setPower(drive,strafe,turn,currentPower);            }    public double adjustedTicks() {        double measuredTicks = ((Math.abs(frontRight.getCurrentPosition()) + Math.abs(frontLeft.getCurrentPosition()) + Math.abs(backRight.getCurrentPosition()) + Math.abs(backLeft.getCurrentPosition())) / 4.0);        double angleAdjustment = (Math.abs(Math.abs(drive) - Math.abs(strafe)) / power - 1) * -1;        return Math.sqrt(Math.pow(measuredTicks, 2) + Math.pow(measuredTicks * angleAdjustment, 2));    }        public void gyroSteering(double targetAngle, double power){        setPowerAuto(power,0, autoPID.update(targetAngle - gyro.getRawAngle()), 1);    }        public void resetMotors(){        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        frontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);    }        public double getRPM(){        double retVal;                long currentTime = System.currentTimeMillis();        long deltaMili = currentTime - timeRing.getValue(currentTime);        double deltaMinutes = deltaMili / 60000.0;                double currentPositionFL = frontLeft.getCurrentPosition();        double currentPositionFR = frontRight.getCurrentPosition();        double currentPositionBL = backLeft.getCurrentPosition();        double currentPositionBR = backRight.getCurrentPosition();                double deltaRotationsFL = Math.abs(currentPositionFL - positionRingFL.getValue(currentPositionFL)) / 537.6;        double deltaRotationsFR = Math.abs(currentPositionFR - positionRingFR.getValue(currentPositionFR)) / 537.6;        double deltaRotationsBL = Math.abs(currentPositionBL - positionRingBL.getValue(currentPositionBL)) / 537.6;        double deltaRotationsBR = Math.abs(currentPositionBR - positionRingBR.getValue(currentPositionBR)) / 537.6;                retVal = ((deltaRotationsFL + deltaRotationsFR + deltaRotationsBL + deltaRotationsBR) / 4.0) / deltaMinutes;                return retVal;    }        public void driveState(double drive, double strafe, double turn, double power){                power = (((power + 1) / -2) + 1.5);        switch ( currentDriveState){                        case STATE_FULL_CONTROL:                setPowerTele(drive, strafe, turn, power);                break;                case STATE_NORTH:                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(0), power);                break;                case STATE_EAST:                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(270), power);                break;                case STATE_SOUTH:                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(180), power);                break;                case STATE_WEST:                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }                setPowerAuto(drive, strafe, closestTarget(90), power);                break;                            case STATE_ADJUSTMENT:                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }                setPowerAuto(drive, strafe, getAdjustmentAngle(), power);                break;        }    }        public void cardinalState(boolean north, boolean east, boolean south, boolean west){        if(north) { newState(DriveState.STATE_NORTH); }        if(east) { newState(DriveState.STATE_EAST); }        if(west) { newState(DriveState.STATE_WEST); }        if(south) { newState(DriveState.STATE_SOUTH); }    }        public void adjustmentState(boolean adjRight, boolean adjLeft, double deltaAngle){        if(adjRight) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() - deltaAngle); }        if(adjLeft) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() + deltaAngle); }    }        public double getAdjustmentAngle(){ return adjustmentAngle; }        public void setAdjustmentAngle(double adjustmentAngle){ this.adjustmentAngle = adjustmentAngle; }        private void newState(DriveState newState) {        currentDriveState = newState;    }        private enum DriveState {        STATE_FULL_CONTROL,        STATE_NORTH,        STATE_EAST,        STATE_SOUTH,        STATE_WEST,        STATE_ADJUSTMENT    }    }