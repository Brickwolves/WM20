Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/MecanumChassis.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.HardwareClasses;\r\rimport android.os.Build;\r\rimport androidx.annotation.RequiresApi;\r\rimport com.qualcomm.robotcore.hardware.DcMotor;\rimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\rimport org.firstinspires.ftc.utilities.PID;\rimport org.firstinspires.ftc.utilities.RingBuffer;\rimport org.firstinspires.ftc.utilities.RingBufferOwen;\r\rimport static java.lang.Math.abs;\rimport static java.lang.Math.floorMod;\r\rpublic class MecanumChassis {\r\r    public DcMotor frontLeft, frontRight, backLeft, backRight;\r    private PID telePID = new PID(.015, 0.0000, .0004, 20);\r    private PID autoPID = new PID(.02, 0.0000, .0004, 20);\r    private final RingBufferOwen timeRing = new RingBufferOwen(20);\r    private final RingBuffer<Double> positionRingFL = new RingBuffer<Double>(20, 0.0);\r    private final RingBuffer<Double> positionRingFR = new RingBuffer<Double>(20, 0.0);\r    private final RingBuffer<Double> positionRingBL = new RingBuffer<Double>(20, 0.0);\r    private final RingBuffer<Double> positionRingBR = new RingBuffer<Double>(20, 0.0);\r    \r    private DriveState currentDriveState = DriveState.STATE_FULL_CONTROL;\r    \r    private Gyro gyro;\r\r    private double drive, strafe, turn, power, targetAngle, bigTurn;\r    private double closestTarget = 0;\r    private double previousTarget = 0;\r    private double turnTime = 0;\r    private double turnYInt = 0;\r    private double unique = 238208;\r    public double currentTicks = 0;\r    public boolean isStrafeFinished = false;\r    private double adjustmentAngle = 0;\r    private boolean fullControlEnabledPrev = false;\r\r    private final static double ACCEL_RATE = 0.001;\r    private static final double TELE_ACCEL = .002;\r\r    //constructor for MecanumChassis. Sets all motors to correct direction and sets them to run with encoders. Also sets target angle and saves all motors.\r    public MecanumChassis(DcMotor frontLeft, DcMotor frontRight, DcMotor backLeft, DcMotor backRight, Gyro gyro, Double targetAngle) {\r        frontRight.setDirection(DcMotorSimple.Direction.FORWARD);\r        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r        backRight.setDirection(DcMotorSimple.Direction.FORWARD);\r        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\r        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        \r        this.frontLeft = frontLeft;\r        this.frontRight = frontRight;\r        this.backLeft = backLeft;\r        this.backRight = backRight;\r        this.gyro = gyro;\r        this.targetAngle = targetAngle;\r    }\r\r    //this is a copy of MecanumChassis except it automatically sets targetAngle to 0\r    public MecanumChassis(DcMotor frontLeft, DcMotor frontRight, DcMotor backLeft, DcMotor backRight, Gyro gyro) {\r        frontRight.setDirection(DcMotorSimple.Direction.FORWARD);\r        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r        backRight.setDirection(DcMotorSimple.Direction.FORWARD);\r        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\r        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\r        this.frontLeft = frontLeft;\r        this.frontRight = frontRight;\r        this.backLeft = backLeft;\r        this.backRight = backRight;\r        this.gyro = gyro;\r        this.targetAngle = 0;\r    }\r\r    public void resetGyro(){\r        gyro.setDatum(gyro.getRawAngle());\r        targetAngle = 0;\r\r    }\r\r    @RequiresApi(api = Build.VERSION_CODES.N)\r    public double closestTarget(double targetAngle){\r        double simpleTargetDelta = floorMod(Math.round(((360 - targetAngle) + gyro.getRawAngle()) * 1e6), Math.round(360.000 * 1e6)) / 1e6;\r        double alternateTargetDelta = -1 * (360 - simpleTargetDelta);\r        return StrictMath.abs(simpleTargetDelta) <= StrictMath.abs(alternateTargetDelta) ? gyro.getRawAngle() - simpleTargetDelta : gyro.getRawAngle() - alternateTargetDelta;\r    }\r\r    //mostly depreciated\r    public void setPower(double drive, double strafe, double turn, double power){\r        this.drive = drive;\r        this.strafe = strafe;\r        this.turn = turn;\r        this.power = power;\r        \r        double flPower = (this.drive - this.strafe - this.turn) * this.power;\r        double frPower = (this.drive + this.strafe + this.turn) * this.power;\r        double blPower = (this.drive + this.strafe - this.turn) * this.power;\r        double brPower = (this.drive - this.strafe + this.turn) * this.power;\r        double maxPower = Math.abs(Math.max(Math.max(Math.abs(flPower), Math.abs(frPower)), Math.max(Math.abs(blPower), Math.abs(brPower))));\r    \r        if (maxPower > 1) {\r            flPower = flPower / maxPower;\r            frPower = frPower / maxPower;\r            blPower = blPower / maxPower;\r            brPower = brPower / maxPower;\r        }\r        \r        if(maxPower < .05 && maxPower > -.05) {\r            flPower = 0;\r            frPower = 0;\r            blPower = 0;\r            brPower = 0;\r        }\r    \r        this.frontLeft.setPower(flPower);\r        this.frontRight.setPower(frPower);\r        this.backLeft.setPower(blPower);\r        this.backRight.setPower(brPower);\r        \r    }\r\r    public void setPowerTele(double drive, double strafe, double turn, double power){\r        double currentTime = System.currentTimeMillis();\r        double deltaTime = currentTime - turnTime;\r        double inputTurn;\r        \r        if (turn != 0) {\r            inputTurn = turn;\r            bigTurn = turn;\r            turnTime = currentTime;\r            turnYInt = bigTurn;\r            targetAngle = gyro.getRawAngle();\r        }else {\r            if(bigTurn > .1) {\r                bigTurn = Math.max(0, -TELE_ACCEL * deltaTime + turnYInt);\r                targetAngle = gyro.getRawAngle();\r            }else if(bigTurn < -.1) {\r                bigTurn = Math.min(0, TELE_ACCEL * deltaTime + turnYInt);\r                targetAngle = gyro.getRawAngle();\r            }else{\r                bigTurn = 0;\r            }\r           inputTurn = telePID.update((targetAngle - gyro.getRawAngle()) / ((getRPM() / 600) + .5));\r            \r        }\r        setPower(drive, strafe, inputTurn, power);\r    }\r\r    public void setPowerTele(double drive, double strafe, double turn){\r        setPowerTele(drive, strafe, turn,1.0);\r    }\r    \r    public void setPowerAuto(double drive, double strafe, double targetAngle, double power){\r        this.targetAngle = targetAngle;\r        turn = autoPID.update(this.targetAngle - gyro.getRawAngle());\r        setPower(drive, strafe, turn, power);\r    }\r    \r    public void strafe(double distance, double heading, double strafeAngle, double targetPower, double startPower, double endPower, int unique){\r        \r        distance = Math.abs(distance);\r        if(startPower == 0){\r            startPower = .05;\r        }\r        startPower = Math.abs(startPower);\r        targetPower = Math.abs(targetPower);\r        endPower = Math.abs(endPower);\r    \r        if (this.unique != unique){\r            resetMotors();\r            this.unique = unique;\r        }\r    \r        double currentAngle = gyro.getRawAngle();\r        double currentDistance = frontLeft.getCurrentPosition();\r        double remainingDistance = distance - currentDistance;\r        \r        double accelRate = 0.003;\r        double acceleratePower = Math.sqrt(accelRate * (currentDistance + 1/accelRate * Math.pow(startPower, 2)));\r        double deceleratePower = Math.sqrt(accelRate * (remainingDistance + 1/accelRate * Math.pow(endPower, 2)));\r        double currentPower = Math.min(Math.min(acceleratePower, deceleratePower), targetPower);\r    \r        double drive = Math.cos(strafeAngle - currentAngle);\r        double strafe = Math.sin(strafeAngle - currentAngle);\r        double turn = autoPID.update(heading - currentAngle);\r    \r        isStrafeFinished = currentDistance >= distance;\r        currentTicks = currentDistance;\r        \r        setPower(drive,strafe,turn,currentPower);\r        \r    }\r\r    public double adjustedTicks() {\r        double measuredTicks = ((Math.abs(frontRight.getCurrentPosition()) + Math.abs(frontLeft.getCurrentPosition()) + Math.abs(backRight.getCurrentPosition()) + Math.abs(backLeft.getCurrentPosition())) / 4.0);\r        double angleAdjustment = (Math.abs(Math.abs(drive) - Math.abs(strafe)) / power - 1) * -1;\r        return Math.sqrt(Math.pow(measuredTicks, 2) + Math.pow(measuredTicks * angleAdjustment, 2));\r    }\r    \r    public void gyroSteering(double targetAngle, double power){\r        setPowerAuto(power,0, autoPID.update(targetAngle - gyro.getRawAngle()), 1);\r    }\r    \r    public void resetMotors(){\r        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\r        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r    }\r    \r    public double getRPM(){\r        double retVal;\r        \r        long currentTime = System.currentTimeMillis();\r        long deltaMili = currentTime - timeRing.getValue(currentTime);\r        double deltaMinutes = deltaMili / 60000.0;\r        \r        double currentPositionFL = frontLeft.getCurrentPosition();\r        double currentPositionFR = frontRight.getCurrentPosition();\r        double currentPositionBL = backLeft.getCurrentPosition();\r        double currentPositionBR = backRight.getCurrentPosition();\r        \r        double deltaRotationsFL = Math.abs(currentPositionFL - positionRingFL.getValue(currentPositionFL)) / 537.6;\r        double deltaRotationsFR = Math.abs(currentPositionFR - positionRingFR.getValue(currentPositionFR)) / 537.6;\r        double deltaRotationsBL = Math.abs(currentPositionBL - positionRingBL.getValue(currentPositionBL)) / 537.6;\r        double deltaRotationsBR = Math.abs(currentPositionBR - positionRingBR.getValue(currentPositionBR)) / 537.6;\r        \r        retVal = ((deltaRotationsFL + deltaRotationsFR + deltaRotationsBL + deltaRotationsBR) / 4.0) / deltaMinutes;\r        \r        return retVal;\r    }\r\r    //sets power for all the motors as needed via setPowerTele and setPowerAuto calls; there are two modes in this method set by whether flyByWire is true: Fly By Wire mode, where all rotation is controlled by the PID system based on targetAngle, and Full Control mode, where the thumbstick can rotate the robot directly when being moved and uses targetAngle when it is not being moved\r    @RequiresApi(api = Build.VERSION_CODES.N)\r    public void driveState(double drive, double strafe, double turn, double power, boolean flyByWire){\r        power = (((power + 1) / -2) + 1.5);\r\r        //FLY BY WIRE MODE: this is the state where the user inputs set the targetAngle, and then only the PID code is adjusting the rotation code\r        if (flyByWire) {\r            setPowerAuto(drive, strafe, targetAngle, power);\r\r        //FULL CONTROL MODE: this is the state where the user can use the thumbstick for small rotation adjustments\r        } else {\r\r            //if the turn thumbstick is not in the neutral positon, power is set manually, and a flag indicating that full control was enabled on the last cycle is set to true\r            if (turn != 0) {\r                setPowerTele(drive, strafe, turn, power);\r                fullControlEnabledPrev = true;\r\r                //if the thumbstick is neutral AND the last cycle was a fullControl cycle, then the targetAngle is set to the gyro angle, setPowerAuto is executed, and the full control flag is reset to false\r            } else if (fullControlEnabledPrev) {\r                targetAngle = gyro.getRawAngle();\r                setPowerAuto(drive, strafe, targetAngle, power);\r                fullControlEnabledPrev = false;\r\r                //if the last cycle was not full control, and the thumbstick is not neutral, then it just executes a setPowerAuto call with targetAngle\r            } else {\r                setPowerAuto(drive, strafe, targetAngle, power);\r            }\r        }\r    }\r\r\r    @RequiresApi(api = Build.VERSION_CODES.N)\r    //if the boolean is true, it sets the targetAngle for the PID system to the closest coterminal angle to the input's respective angle (North 0, East 270, South 180, West 90) with priority being in that order\r    public void setCardinalAngle(boolean northInput, boolean eastInput, boolean southInput, boolean westInput){\r        if (northInput) {\r            targetAngle = closestTarget(0);\r        }\r        if (eastInput) {\r            targetAngle = closestTarget(270);\r        }\r        if (southInput) {\r            targetAngle = closestTarget(180);\r        }\r        if (westInput) {\r            targetAngle = closestTarget(90);\r        }\r    }\r\r    //sets the targetAngle for the PID system to the angle the input thumbstick is being pushed in if it is beyond a .1 deadzone\r    @RequiresApi(api = Build.VERSION_CODES.N)\r    public void setTargetAngle(Controller.Thumbstick thumbstickAngleInput){\r        if(abs(thumbstickAngleInput.getX()) > .1 || abs(thumbstickAngleInput.getY()) > .1){\r            targetAngle = closestTarget(thumbstickAngleInput.getAngle());\r        }\r    }\r\r    /*\r    public void adjustmentState(boolean adjRight, boolean adjLeft, double deltaAngle){\r        if(adjRight) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() - deltaAngle); }\r        if(adjLeft) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() + deltaAngle); }\r    }\r     */\r    \r    public double getAdjustmentAngle(){ return adjustmentAngle; }\r    \r    public void setAdjustmentAngle(double adjustmentAngle){ this.adjustmentAngle = adjustmentAngle; }\r    \r    private void newState(DriveState newState) {\r        currentDriveState = newState;\r    }\r    \r    private enum DriveState {\r        STATE_FULL_CONTROL,\r        STATE_FLY_BY_WIRE\r    }\r    \r}\r
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/MecanumChassis.java	(revision ebaf536f53dc6e18eba129000a44b864b4af423d)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/MecanumChassis.java	(date 1612287792000)
@@ -275,12 +275,50 @@
             }         }     }+    +    @RequiresApi(api = Build.VERSION_CODES.N)+    public void driveState(double drive, double strafe, double turn, double power){+        power = (((power + 1) / -2) + 1.5);+        switch ( currentDriveState){+        +            case STATE_FULL_CONTROL:+                setPowerTele(drive, strafe, turn, power);+                break;+        +            case STATE_NORTH:+                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }+                setPowerAuto(drive, strafe, closestTarget(0), power);+                break;+        +            case STATE_EAST:+                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }+                setPowerAuto(drive, strafe, closestTarget(270), power);+                break;+        +            case STATE_SOUTH:+                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }+                setPowerAuto(drive, strafe, closestTarget(180), power);+                break;+        +            case STATE_WEST:+                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }+                setPowerAuto(drive, strafe, closestTarget(90), power);+                break;+        +            case STATE_ADJUSTMENT:+                if(turn != 0) { newState(DriveState.STATE_FULL_CONTROL); break; }+                setPowerAuto(drive, strafe, getAdjustmentAngle(), power);+                break;+        }+        +    }       @RequiresApi(api = Build.VERSION_CODES.N)     //if the boolean is true, it sets the targetAngle for the PID system to the closest coterminal angle to the input's respective angle (North 0, East 270, South 180, West 90) with priority being in that order     public void setCardinalAngle(boolean northInput, boolean eastInput, boolean southInput, boolean westInput){         if (northInput) {+                         targetAngle = closestTarget(0);         }         if (eastInput) {@@ -302,12 +340,12 @@
         }     } -    /*+         public void adjustmentState(boolean adjRight, boolean adjLeft, double deltaAngle){         if(adjRight) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() - deltaAngle); }         if(adjLeft) { newState(DriveState.STATE_ADJUSTMENT); setAdjustmentAngle(gyro.getRawAngle() + deltaAngle); }     }-     */+              public double getAdjustmentAngle(){ return adjustmentAngle; }     @@ -319,7 +357,12 @@
          private enum DriveState {         STATE_FULL_CONTROL,-        STATE_FLY_BY_WIRE+        STATE_FLY_BY_WIRE,+        STATE_NORTH,+        STATE_EAST,+        STATE_SOUTH,+        STATE_WEST,+        STATE_ADJUSTMENT     }     -}
\ No newline at end of file
+}Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Intake.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.HardwareClasses;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.hardware.Servo;\n\npublic class Intake {\n\n    private DcMotor intakeDrive;\n    private Servo reachOne;\n    private Servo reachTwo;\n    private final static double RETRACTED = 0.29;\n    private final static double DEPLOYED = 0.0;\n    private final static double INTAKE_ON = 1.0;\n    private final static double INTAKE_REVERSE = .75;\n    \n    private IntakeState currentIntakeState = IntakeState.STATE_OFF;\n    private ReachState currentReachState = ReachState.STATE_RETRACT;\n\n    public Intake(DcMotor intakeDrive, Servo reachOne, Servo reachTwo){\n        intakeDrive.setDirection(DcMotorSimple.Direction.REVERSE);\n        this.intakeDrive = intakeDrive;\n        this.reachOne = reachOne;\n        this.reachTwo = reachTwo;\n    }\n\n    public void retractReach(){\n        reachOne.setPosition(RETRACTED);\n        reachTwo.setPosition(-RETRACTED+1);\n    }\n\n    public void deployReach(){\n        reachOne.setPosition(DEPLOYED);\n        reachTwo.setPosition(-DEPLOYED+1);\n    }\n    \n    public void reachState(boolean deployToggle){\n        switch (currentReachState) {\n            \n            case STATE_RETRACT:\n                if (deployToggle) { newState(ReachState.STATE_DEPLOY); break; }\n                retractReach();\n                break;\n            \n            case STATE_DEPLOY:\n                if (deployToggle) { newState(ReachState.STATE_RETRACT); newState(IntakeState.STATE_OFF); break; }\n                deployReach();\n                break;\n        }\n    }\n    \n\n    public void intakeOn(){ intakeDrive.setPower(INTAKE_ON); }\n\n    public void intakeOff(){ intakeDrive.setPower(0.0); }\n\n    public void intakeReverse(){ intakeDrive.setPower(INTAKE_ON * -INTAKE_REVERSE); }\n    \n    public void intakeState(boolean intakeOn, boolean intakeOff, boolean intakeReverse){\n        switch (currentIntakeState) {\n            \n            case STATE_OFF:\n                if (intakeOn) { newState(IntakeState.STATE_ON); newState(ReachState.STATE_DEPLOY); break; }\n                if (intakeReverse) { intakeReverse(); newState(ReachState.STATE_DEPLOY); break; }\n                intakeOff();\n                break;\n                \n            case STATE_ON:\n                if (intakeReverse) { intakeReverse(); break; }\n                if (intakeOff) { newState(IntakeState.STATE_OFF); break; }\n                intakeOn();\n                break;\n        }\n    }\n    \n    \n    \n    \n    private void newState(IntakeState newState) {\n        currentIntakeState = newState;\n    }\n    \n    private void newState(ReachState newState) {\n        currentReachState = newState;\n    }\n    \n    private enum IntakeState {\n        STATE_OFF,\n        STATE_ON,\n        STATE_REVERSE\n    }\n    \n    private enum ReachState {\n        STATE_RETRACT,\n        STATE_DEPLOY\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Intake.java	(revision d6b9fd2eb0830f6092820c49bf5ec0dc1567dadf)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Intake.java	(date 1612284869000)
@@ -5,7 +5,7 @@
 import com.qualcomm.robotcore.hardware.Servo;
 
 public class Intake {
-
+    
     private DcMotor intakeDrive;
     private Servo reachOne;
     private Servo reachTwo;
@@ -16,19 +16,19 @@
     
     private IntakeState currentIntakeState = IntakeState.STATE_OFF;
     private ReachState currentReachState = ReachState.STATE_RETRACT;
-
+    
     public Intake(DcMotor intakeDrive, Servo reachOne, Servo reachTwo){
         intakeDrive.setDirection(DcMotorSimple.Direction.REVERSE);
         this.intakeDrive = intakeDrive;
         this.reachOne = reachOne;
         this.reachTwo = reachTwo;
     }
-
+    
     public void retractReach(){
         reachOne.setPosition(RETRACTED);
         reachTwo.setPosition(-RETRACTED+1);
     }
-
+    
     public void deployReach(){
         reachOne.setPosition(DEPLOYED);
         reachTwo.setPosition(-DEPLOYED+1);
@@ -49,11 +49,11 @@
         }
     }
     
-
+    
     public void intakeOn(){ intakeDrive.setPower(INTAKE_ON); }
-
+    
     public void intakeOff(){ intakeDrive.setPower(0.0); }
-
+    
     public void intakeReverse(){ intakeDrive.setPower(INTAKE_ON * -INTAKE_REVERSE); }
     
     public void intakeState(boolean intakeOn, boolean intakeOff, boolean intakeReverse){
@@ -64,7 +64,7 @@
                 if (intakeReverse) { intakeReverse(); newState(ReachState.STATE_DEPLOY); break; }
                 intakeOff();
                 break;
-                
+            
             case STATE_ON:
                 if (intakeReverse) { intakeReverse(); break; }
                 if (intakeOff) { newState(IntakeState.STATE_OFF); break; }
@@ -94,5 +94,5 @@
         STATE_RETRACT,
         STATE_DEPLOY
     }
-
+    
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Controller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.HardwareClasses;\n\nimport com.qualcomm.robotcore.hardware.Gamepad;\n\npublic class Controller {\n\t\n\t\n\tprivate final Gamepad gamepad;\n\tprivate boolean isSq;\n\tprivate boolean isTr;\n\tprivate boolean isCi;\n\tprivate boolean isCr;\n\tprivate boolean isUp;\n\tprivate boolean isLeft;\n\tprivate boolean isDown;\n\tprivate boolean isRight;\n\tprivate boolean isLS;\n\tprivate boolean isRS;\n\tprivate boolean isLB;\n\tprivate boolean isRB;\n\tprivate boolean toggleSq = false;\n\tprivate boolean toggleTr = false;\n\tprivate boolean toggleCr = false;\n\tprivate boolean toggleCi = false;\n\tprivate boolean toggleUp = false;\n\tprivate boolean toggleDown = false;\n\tprivate boolean toggleLeft = false;\n\tprivate boolean toggleRight = false;\n\tprivate boolean toggleLS = false;\n\tprivate boolean toggleRS = false;\n\tprivate boolean toggleLB = false;\n\tprivate boolean toggleRB = false;\n\tprivate boolean pressSq = false;\n\tprivate boolean pressTr = false;\n\tprivate boolean pressCr = false;\n\tprivate boolean pressCi = false;\n\tprivate boolean pressUp = false;\n\tprivate boolean pressDown = false;\n\tprivate boolean pressLeft = false;\n\tprivate boolean pressRight = false;\n\tprivate boolean pressLS = false;\n\tprivate boolean pressRS = false;\n\tprivate boolean pressLB = false;\n\tprivate boolean pressRB = false;\n\t\n\t\n\tpublic Controller(Gamepad gamepad) {\n\t\tthis.gamepad = gamepad;\n\t}\n\t\n\tpublic Thumbstick getRightThumbstick() {\n\t\treturn new Controller.Thumbstick(gamepad.right_stick_x, gamepad.right_stick_y);\n\t}\n\t\n\tpublic Thumbstick getLeftThumbstick() {\n\t\treturn new Controller.Thumbstick(gamepad.left_stick_x, gamepad.left_stick_y);\n\t}\n\t\n\t//cross\n\tpublic boolean cross() {\n\t\treturn gamepad.a;\n\t}\n\t\n\tpublic boolean crossPressUpdate() {\n\t\tboolean wasCr = isCr;\n\t\treturn (pressCr = (isCr = gamepad.a) && !wasCr);\n\t}\n\t\n\tpublic boolean crossPress() {\n\t\treturn pressCr;\n\t}\n\t\n\tpublic boolean crossToggle() {\n\t\tboolean wasCr = isCr;\n\t\tif ((isCr = gamepad.a) && !wasCr) {\n\t\t\ttoggleCr = !toggleCr;\n\t\t}\n\t\treturn (toggleCr);\n\t}\n\t\n\t\n\t//circle\n\tpublic boolean circle() {\n\t\treturn gamepad.b;\n\t}\n\t\n\tpublic boolean circlePressUpdate() {\n\t\tboolean wasCi = isCi;\n\t\treturn (pressCi = (isCi = gamepad.b) && !wasCi);\n\t}\n\t\n\tpublic boolean circlePress() {\n\t\treturn pressCi;\n\t}\n\t\n\tpublic boolean circleToggle() {\n\t\tboolean wasCi = isCi;\n\t\tif ((isCi = gamepad.b) && !wasCi) {\n\t\t\ttoggleCi = !toggleCi;\n\t\t}\n\t\treturn (toggleCi);\n\t}\n\t\n\t\n\t//square\n\tpublic boolean square() {\n\t\treturn gamepad.x;\n\t}\n\t\n\tpublic boolean squarePressUpdate() {\n\t\tboolean wasSq = isSq;\n\t\treturn (pressSq = (isSq = gamepad.x) && !wasSq);\n\t}\n\t\n\tpublic boolean squarePress() {\n\t\treturn pressSq;\n\t}\n\t\n\tpublic boolean squareToggle() {\n\t\tboolean wasSq = isSq;\n\t\tif ((isSq = gamepad.x) && !wasSq) {\n\t\t\ttoggleSq = !toggleSq;\n\t\t}\n\t\treturn (toggleSq);\n\t}\n\t\n\t\n\t//triangle\n\tpublic boolean triangle() {\n\t\treturn gamepad.y;\n\t}\n\t\n\tpublic boolean trianglePressUpdate() {\n\t\tboolean wasTr = isTr;\n\t\treturn (pressTr = (isTr = gamepad.y) && !wasTr);\n\t}\n\t\n\tpublic boolean trianglePress() {\n\t\treturn pressTr;\n\t}\n\t\n\tpublic boolean triangleToggle() {\n\t\tboolean wasTr = isTr;\n\t\tif ((isTr = gamepad.y) && !wasTr) {\n\t\t\ttoggleTr = !toggleTr;\n\t\t}\n\t\treturn (toggleTr);\n\t}\n\t\n\t\n\t//dpad up\n\tpublic boolean up() {\n\t\treturn gamepad.dpad_up;\n\t}\n\t\n\tpublic boolean upPressUpdate() {\n\t\tboolean wasUp = isUp;\n\t\treturn (pressUp = (isUp = gamepad.dpad_up) && !wasUp);\n\t}\n\t\n\tpublic boolean upPress() {\n\t\treturn pressUp;\n\t}\n\t\n\tpublic boolean upToggle() {\n\t\tboolean wasUp = isUp;\n\t\tif ((isUp = gamepad.dpad_up) && !wasUp) {\n\t\t\ttoggleUp = !toggleUp;\n\t\t}\n\t\treturn (toggleUp);\n\t}\n\t\n\t\n\t//dpad down\n\tpublic boolean down() {\n\t\treturn gamepad.dpad_down;\n\t}\n\t\n\tpublic boolean downPressUpdate() {\n\t\tboolean wasDown = isDown;\n\t\treturn (pressDown = (isDown = gamepad.dpad_down) && !wasDown);\n\t}\n\t\n\tpublic boolean downPress() {\n\t\treturn pressDown;\n\t}\n\t\n\tpublic boolean downToggle() {\n\t\tboolean wasDown = isDown;\n\t\tif ((isDown = gamepad.dpad_down) && !wasDown) {\n\t\t\ttoggleDown = !toggleDown;\n\t\t}\n\t\treturn (toggleDown);\n\t}\n\t\n\t\n\t//dpad left\n\tpublic boolean left() {\n\t\treturn gamepad.dpad_left;\n\t}\n\t\n\tpublic boolean leftPressUpdate() {\n\t\tboolean wasLeft = isLeft;\n\t\treturn (pressLeft = (isLeft = gamepad.dpad_left) && !wasLeft);\n\t}\n\t\n\tpublic boolean leftPress() {\n\t\treturn pressLeft;\n\t}\n\t\n\tpublic boolean leftToggle() {\n\t\tboolean wasLeft = isLeft;\n\t\tif ((isLeft = gamepad.dpad_left) && !wasLeft) {\n\t\t\ttoggleLeft = !toggleLeft;\n\t\t}\n\t\treturn (toggleLeft);\n\t}\n\t\n\t\n\t//dpad right\n\tpublic boolean right() {\n\t\treturn gamepad.dpad_right;\n\t}\n\t\n\tpublic boolean rightPressUpdate() {\n\t\tboolean wasRight = isRight;\n\t\treturn (pressRight = (isRight = gamepad.dpad_right) && !wasRight);\n\t}\n\t\n\tpublic boolean rightPress() {\n\t\treturn pressRight;\n\t}\n\t\n\tpublic boolean rightToggle() {\n\t\tboolean wasRight = isRight;\n\t\tif ((isRight = gamepad.dpad_right) && !wasRight) {\n\t\t\ttoggleRight = !toggleRight;\n\t\t}\n\t\treturn (toggleRight);\n\t}\n\t\n\t\n\t//left stick button\n\tpublic boolean LS() {\n\t\treturn gamepad.left_stick_button;\n\t}\n\t\n\tpublic boolean LSPressUpdate() {\n\t\tboolean wasLS = isLS;\n\t\treturn (pressLS = (isLS = gamepad.left_stick_button) && !wasLS);\n\t}\n\t\n\tpublic boolean LSPress() {\n\t\treturn pressLS;\n\t}\n\t\n\tpublic boolean LSToggle() {\n\t\tboolean wasLS = isLS;\n\t\tif ((isLS = gamepad.left_stick_button) && !wasLS) {\n\t\t\ttoggleLS = !toggleLS;\n\t\t}\n\t\treturn (toggleLS);\n\t}\n\t\n\t\n\t//right stick button\n\tpublic boolean RS() {\n\t\treturn gamepad.right_stick_button;\n\t}\n\t\n\tpublic boolean RSPressUpdate() {\n\t\tboolean wasRS = isRS;\n\t\treturn (pressRS = (isRS = gamepad.right_stick_button) && !wasRS);\n\t}\n\t\n\tpublic boolean RSPress() {\n\t\treturn pressRS;\n\t}\n\t\n\tpublic boolean RSToggle() {\n\t\tboolean wasRS = isRS;\n\t\tif ((isRS = gamepad.right_stick_button) && !wasRS) {\n\t\t\ttoggleRS = !toggleRS;\n\t\t}\n\t\treturn (toggleRS);\n\t}\n\t\n\t\n\t//left bumper\n\tpublic boolean LB() {\n\t\treturn gamepad.left_bumper;\n\t}\n\t\n\tpublic boolean LBPressUpdate() {\n\t\tboolean wasLB = isLB;\n\t\treturn (pressLB = (isLB = gamepad.left_bumper) && !wasLB);\n\t}\n\t\n\tpublic boolean LBPress() {\n\t\treturn pressLB;\n\t}\n\t\n\tpublic boolean LBToggle() {\n\t\tboolean wasLB = isLB;\n\t\tif ((isLB = gamepad.left_bumper) && !wasLB) {\n\t\t\ttoggleLB = !toggleLB;\n\t\t}\n\t\treturn (toggleLB);\n\t}\n\t\n\t\n\t//right bumper\n\tpublic boolean RB() {\n\t\treturn gamepad.right_bumper;\n\t}\n\t\n\tpublic boolean RBPressUpdate() {\n\t\tboolean wasRB = isRB;\n\t\treturn (pressRB = (isRB = gamepad.right_bumper) && !wasRB);\n\t}\n\t\n\tpublic boolean RBPress() {\n\t\treturn pressRB;\n\t}\n\t\n\tpublic boolean RBToggle() {\n\t\tboolean wasRB = isRB;\n\t\tif ((isRB = gamepad.right_bumper) && !wasRB) {\n\t\t\ttoggleRB = !toggleRB;\n\t\t}\n\t\treturn (toggleRB);\n\t}\n\t\n\t\n\t//left trigger\n\tpublic float LT() {\n\t\treturn gamepad.left_trigger;\n\t}\n\t\n\t\n\t//right trigger\n\tpublic float RT() {\n\t\treturn gamepad.right_trigger;\n\t}\n\t\n\t\n\tpublic boolean options() {\n\t\treturn gamepad.options;\n\t}\n\t\n\t\n\tpublic boolean share() {\n\t\treturn gamepad.share;\n\t}\n\t\n\t\n\tpublic class Thumbstick {\n\t\t\n\t\tprivate final double rawX;\n\t\tprivate final double rawY;\n\t\tprivate double shiftedX;\n\t\tprivate double shiftedY;\n\t\t\n\t\tpublic Thumbstick(Double x, Double y) {\n\t\t\tthis.rawX = x;\n\t\t\tthis.rawY = y;\n\t\t}\n\t\t\n\t\tpublic Thumbstick(Float x, Float y) {\n\t\t\tthis.rawX = x;\n\t\t\tthis.rawY = y;\n\t\t}\n\t\t\n\t\tpublic boolean isInput() {\n\t\t\treturn (getX() != 0) || (getY() != 0);\n\t\t}\n\t\t\n\t\tpublic double getX() {\n\t\t\treturn rawX;\n\t\t}\n\t\t\n\t\tpublic double getY() {\n\t\t\treturn rawY;\n\t\t}\n\t\t\n\t\tpublic void setShift(double shiftAngle) {\n\t\t\tthis.shiftedX = (this.rawX * Math.cos(Math.toRadians(shiftAngle))) - (this.rawY * Math.sin(Math.toRadians(shiftAngle)));\n\t\t\tthis.shiftedY = (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle)));\n\t\t}\n\t\t\n\t\tpublic double getShiftedX() {\n\t\t\treturn shiftedX;\n\t\t}\n\t\t\n\t\tpublic double getShiftedY() {\n\t\t\treturn shiftedY;\n\t\t}\n\t\t\n\t\tpublic double getShiftedX(Double shiftAngle) {\n\t\t\treturn (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle)));\n\t\t}\n\t\t\n\t\tpublic double getShiftedY(Double shiftAngle) {\n\t\t\treturn (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle)));\n\t\t}\n\t\t\n\t\tpublic double getInvertedX() {\n\t\t\treturn rawX * -1;\n\t\t}\n\t\t\n\t\tpublic double getInvertedY() {\n\t\t\treturn rawY * -1;\n\t\t}\n\t\t\n\t\tpublic double getInvertedShiftedX() {\n\t\t\treturn shiftedX * -1;\n\t\t}\n\t\t\n\t\tpublic double getInvertedShiftedY() {\n\t\t\treturn shiftedY * -1;\n\t\t}\n\t\t\n\t\tpublic double getInvertedShiftedX(Double shiftAngle) {\n\t\t\treturn (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle))) * -1;\n\t\t}\n\t\t\n\t\tpublic double getInvertedShiftedY(Double shiftAngle) {\n\t\t\treturn (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle))) * -1;\n\t\t}\n\n\t\tpublic double getAngle(){\n\t\t\treturn ((270 - (Math.atan2(0 - getInvertedY(), 0 - getInvertedX())) * 180 / Math.PI) % 360);\n\t\t}\n\t\t\n\t\t\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Controller.java	(revision d6b9fd2eb0830f6092820c49bf5ec0dc1567dadf)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareClasses/Controller.java	(date 1612284529000)
@@ -427,7 +427,7 @@
 		public double getInvertedShiftedY(Double shiftAngle) {
 			return (this.rawX * Math.sin(Math.toRadians(shiftAngle))) + (this.rawY * Math.cos(Math.toRadians(shiftAngle))) * -1;
 		}
-
+		
 		public double getAngle(){
 			return ((270 - (Math.atan2(0 - getInvertedY(), 0 - getInvertedX())) * 180 / Math.PI) % 360);
 		}
